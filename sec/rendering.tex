\subsection{Rendering}
It is required to render the model for silhouette energy and for visualization purposes. The full rendering process is done in fragment shader, the vertex shader only provides a quad. 
In fragment shader, given the fragment coordinates gl\_FragCoord, we compute the camera ray corresponding to the current pixel, but de-applying the transformations done by the rasterizer to the points $\{$gl\_FragCoord.x, gl\_FragCoord.y, 0$\}$ and $\{$gl\_FragCoord.x, gl\_FragCoord.y, 1$\}$ that correspond to the points on the near and far camera plane in the world coordinates.

Once we have the ray, we intersect it with each block of the model. The intersection points of a ray with a sphere, plane and conic surface are found in closed form. We also compute the normals at intersection points for shading. This takes 20 milliseconds for a window size $1280 \times 960$ which is prohibitively show.

\textbf{Optimization.} To speed up the rendering, we first render an indicator texture of size $320 \times 240$ that contains model silhouette with the number of each model block and a value 255 for background. Once the texture is accessed from the fragment shader, it is automatically interpolated for the window size  $1280 \times 960$. We only consider the rays for which the value of the indicator texture is less than 255. The change in resolution is handled by the ``blured`` boundaries of the model. This allows to decrease rendering time to 6-7 millisecond. 

We use one more heuristic, if the value of the indicator texture is very close to an integer, this means that the pixel is on the middle of a block and we can only intersect the corresponding ray with that block. If the  value is not an integer, than the intersection is done with all the blocks. This brings the rendering time down to 4-5 ms. \Anastasia{But with this I get white pixels at the intersection line of the blocks that have very different indices, like 3 and 20. I have no idea why. Also, if while reading this you got an idea how to speed up rendering some more, please let me know, it would be great. Also I tried running glFinish, after offscreen renderer and nothing changed, I still have exactly the same issues.}